#!/usr/bin/env python3
"""
password_analyzer.py

This module analyzes passwords generated by DarkForge or imported from other sources.
It evaluates password strength, identifies patterns, and generates reports.

Author: Shivendra Chauhan
Date: 23rd March 2025
"""

import re
import math
import json
from typing import List, Dict, Any, Optional
from collections import Counter
import matplotlib.pyplot as plt
from pathlib import Path

# -----------------------------------------------------------------------------
# Password Strength Assessment
# -----------------------------------------------------------------------------

def calculate_entropy(password: str) -> float:
    """
    Calculate the entropy of a password as a measure of its strength.
    
    Entropy = L * log2(R), where:
    - L is the length of the password
    - R is the size of the pool of unique characters
    
    Args:
        password: The password to analyze
        
    Returns:
        float: The calculated entropy in bits
    """
    if not password:
        return 0.0
    
    # Calculate character pool size
    has_lowercase = bool(re.search(r'[a-z]', password))
    has_uppercase = bool(re.search(r'[A-Z]', password))
    has_digits = bool(re.search(r'[0-9]', password))
    has_symbols = bool(re.search(r'[^a-zA-Z0-9]', password))
    
    pool_size = 0
    if has_lowercase:
        pool_size += 26
    if has_uppercase:
        pool_size += 26
    if has_digits:
        pool_size += 10
    if has_symbols:
        pool_size += 33  # Approximation for common symbols
    
    # Calculate entropy
    entropy = len(password) * math.log2(max(pool_size, 1))
    return entropy

def rate_password_strength(password: str) -> Dict[str, Any]:
    """
    Rate the strength of a password based on various factors.
    
    Args:
        password: The password to analyze
        
    Returns:
        Dict: A dictionary containing strength metrics and rating
    """
    entropy = calculate_entropy(password)
    
    # Define strength categories
    if entropy < 28:
        strength = "Very Weak"
        score = 1
    elif entropy < 36:
        strength = "Weak"
        score = 2
    elif entropy < 60:
        strength = "Moderate"
        score = 3
    elif entropy < 80:
        strength = "Strong"
        score = 4
    else:
        strength = "Very Strong"
        score = 5
    
    # Check for common patterns
    has_common_pattern = False
    common_patterns = [
        r'12345',
        r'qwerty',
        r'password',
        r'admin',
        r'welcome',
        r'123456789',
    ]
    
    for pattern in common_patterns:
        if re.search(pattern, password.lower()):
            has_common_pattern = True
            break
    
    # Adjust score based on patterns
    if has_common_pattern:
        score = max(1, score - 2)
        
    return {
        "password": password,
        "entropy": entropy,
        "strength": strength,
        "score": score,
        "has_common_pattern": has_common_pattern,
        "length": len(password)
    }

# -----------------------------------------------------------------------------
# Pattern Analysis
# -----------------------------------------------------------------------------

def analyze_patterns(passwords: List[str]) -> Dict[str, Any]:
    """
    Analyze patterns across a list of passwords.
    
    Args:
        passwords: List of passwords to analyze
        
    Returns:
        Dict: Analysis results including pattern frequency and statistics
    """
    if not passwords:
        return {}
    
    results = {
        "total_passwords": len(passwords),
        "length_stats": {},
        "character_stats": {},
        "pattern_stats": {},
        "strength_distribution": {
            "Very Weak": 0,
            "Weak": 0,
            "Moderate": 0,
            "Strong": 0,
            "Very Strong": 0
        }
    }
    
    # Analyze lengths
    lengths = [len(pwd) for pwd in passwords]
    results["length_stats"] = {
        "min": min(lengths),
        "max": max(lengths),
        "avg": sum(lengths) / len(lengths),
        "distribution": dict(Counter(lengths))
    }
    
    # Analyze character composition
    has_lowercase = sum(1 for pwd in passwords if re.search(r'[a-z]', pwd))
    has_uppercase = sum(1 for pwd in passwords if re.search(r'[A-Z]', pwd))
    has_digits = sum(1 for pwd in passwords if re.search(r'[0-9]', pwd))
    has_symbols = sum(1 for pwd in passwords if re.search(r'[^a-zA-Z0-9]', pwd))
    
    results["character_stats"] = {
        "lowercase_percent": (has_lowercase / len(passwords)) * 100,
        "uppercase_percent": (has_uppercase / len(passwords)) * 100,
        "digits_percent": (has_digits / len(passwords)) * 100,
        "symbols_percent": (has_symbols / len(passwords)) * 100
    }
    
    # Analyze strength distribution
    strength_scores = [rate_password_strength(pwd) for pwd in passwords]
    for score in strength_scores:
        results["strength_distribution"][score["strength"]] += 1
    
    # Convert to percentages
    for key, value in results["strength_distribution"].items():
        results["strength_distribution"][key] = (value / len(passwords)) * 100
    
    return results

# -----------------------------------------------------------------------------
# Visualization Functions
# -----------------------------------------------------------------------------

def generate_visualizations(analysis_results: Dict[str, Any], output_dir: str) -> None:
    """
    Generate visualizations from password analysis results.
    
    Args:
        analysis_results: Results from analyze_patterns function
        output_dir: Directory to save visualizations
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Length distribution visualization
    plt.figure(figsize=(10, 6))
    lengths = analysis_results["length_stats"]["distribution"]
    plt.bar(lengths.keys(), lengths.values())
    plt.title("Password Length Distribution")
    plt.xlabel("Password Length")
    plt.ylabel("Frequency")
    plt.grid(True, alpha=0.3)
    plt.savefig(output_path / "length_distribution.png")
    plt.close()
    
    # Character composition visualization
    plt.figure(figsize=(10, 6))
    char_stats = analysis_results["character_stats"]
    plt.bar(char_stats.keys(), char_stats.values())
    plt.title("Character Type Distribution")
    plt.xlabel("Character Type")
    plt.ylabel("Percentage (%)")
    plt.ylim(0, 100)
    plt.grid(True, alpha=0.3)
    plt.savefig(output_path / "character_distribution.png")
    plt.close()
    
    # Strength distribution visualization
    plt.figure(figsize=(10, 6))
    strength_dist = analysis_results["strength_distribution"]
    plt.pie(
        strength_dist.values(),
        labels=strength_dist.keys(),
        autopct='%1.1f%%',
        startangle=90
    )
    plt.title("Password Strength Distribution")
    plt.savefig(output_path / "strength_distribution.png")
    plt.close()

# -----------------------------------------------------------------------------
# Report Generation
# -----------------------------------------------------------------------------

def generate_report(analysis_results: Dict[str, Any], output_file: str) -> None:
    """
    Generate a JSON report from the analysis results.
    
    Args:
        analysis_results: Results from analyze_patterns function
        output_file: Path to save the JSON report
    """
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(analysis_results, f, indent=2)

# -----------------------------------------------------------------------------
# Main Function
# -----------------------------------------------------------------------------

def analyze_password_file(password_file: str, output_dir: str, generate_visuals: bool = True) -> Dict[str, Any]:
    """
    Analyze a file containing passwords (one per line).
    
    Args:
        password_file: Path to the file containing passwords
        output_dir: Directory to save reports and visualizations
        generate_visuals: Whether to generate visualizations
        
    Returns:
        Dict: Analysis results
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Read passwords from file
    with open(password_file, 'r', encoding='utf-8') as f:
        passwords = [line.strip() for line in f if line.strip()]
    
    # Analyze patterns
    analysis_results = analyze_patterns(passwords)
    
    # Generate report
    report_file = output_path / "password_analysis_report.json"
    generate_report(analysis_results, report_file)
    
    # Generate visualizations if requested
    if generate_visuals:
        visualization_dir = output_path / "visualizations"
        generate_visualizations(analysis_results, visualization_dir)
    
    return analysis_results

# -----------------------------------------------------------------------------
# CLI
# -----------------------------------------------------------------------------

if __name__ == "__main__":
    import click
    
    @click.command()
    @click.option(
        "--password-file",
        required=True,
        help="File containing passwords to analyze (one per line)"
    )
    @click.option(
        "--output-dir",
        default="./analysis_results",
        help="Directory to save analysis results"
    )
    @click.option(
        "--no-visuals",
        is_flag=True,
        help="Disable visualization generation"
    )
    def main(password_file, output_dir, no_visuals):
        """Analyze passwords and generate reports."""
        try:
            analysis_results = analyze_password_file(
                password_file=password_file,
                output_dir=output_dir,
                generate_visuals=not no_visuals
            )
            
            click.echo(f"Analysis complete!")
            click.echo(f"Total passwords analyzed: {analysis_results['total_passwords']}")
            click.echo(f"Average password length: {analysis_results['length_stats']['avg']:.2f}")
            click.echo(f"Report saved to: {output_dir}/password_analysis_report.json")
            
            if not no_visuals:
                click.echo(f"Visualizations saved to: {output_dir}/visualizations/")
        
        except Exception as e:
            click.echo(f"Error: {e}", err=True)
            raise
    
    main() 