#!/usr/bin/env python3
"""
password_analyzer.py

This module analyzes passwords generated by DarkForge or imported from other sources.
It evaluates password strength, identifies patterns, and generates reports.

Author: Shivendra Chauhan
Date: 23rd March 2025
"""

import re
import math
import json
from typing import List, Dict, Any, Optional
from collections import Counter
import matplotlib.pyplot as plt
from pathlib import Path
import click
from datetime import datetime

# -----------------------------------------------------------------------------
# Pattern Detection
# -----------------------------------------------------------------------------

PATTERNS = {
    "common_sequences": [
        r'12345',
        r'qwerty',
        r'password',
        r'admin',
        r'welcome',
        r'123456789',
        r'abc123',
        r'111111',
        r'123123',
        r'12345678',
        r'1234567',
        r'123456',
        r'12345',
        r'1234',
        r'123',
        r'12',
        r'1',
    ],
    "keyboard_patterns": [
        r'qwerty',
        r'asdfgh',
        r'zxcvbn',
        r'qwertz',
        r'azerty',
        r'qwertyuiop',
        r'asdfghjkl',
        r'zxcvbnm',
    ],
    "date_patterns": [
        r'\d{4}',  # Year
        r'\d{2}/\d{2}/\d{4}',  # MM/DD/YYYY
        r'\d{4}/\d{2}/\d{2}',  # YYYY/MM/DD
        r'\d{2}-\d{2}-\d{4}',  # MM-DD-YYYY
        r'\d{4}-\d{2}-\d{2}',  # YYYY-MM-DD
    ],
    "special_char_patterns": [
        r'[!@#$%^&*]',  # Common special chars
        r'[^a-zA-Z0-9]',  # Any non-alphanumeric
    ],
    "case_patterns": [
        r'^[A-Z]+$',  # All uppercase
        r'^[a-z]+$',  # All lowercase
        r'^[A-Z][a-z]+$',  # Capitalized
        r'^[a-z]+[A-Z]+$',  # camelCase
    ],
    "length_patterns": [
        r'^.{8,}$',  # 8 or more chars
        r'^.{12,}$',  # 12 or more chars
        r'^.{16,}$',  # 16 or more chars
    ],
}

def detect_patterns(password: str) -> Dict[str, List[str]]:
    """
    Detect various patterns in a password.
    
    Args:
        password: The password to analyze
        
    Returns:
        Dict: Dictionary of pattern types and matches
    """
    patterns_found = {}
    
    for pattern_type, patterns in PATTERNS.items():
        matches = []
        for pattern in patterns:
            if re.search(pattern, password):
                matches.append(pattern)
        if matches:
            patterns_found[pattern_type] = matches
            
    return patterns_found

# -----------------------------------------------------------------------------
# Password Strength Assessment
# -----------------------------------------------------------------------------

def calculate_entropy(password: str) -> float:
    """
    Calculate the entropy of a password as a measure of its strength.
    
    Entropy = L * log2(R), where:
    - L is the length of the password
    - R is the size of the pool of unique characters
    
    Args:
        password: The password to analyze
        
    Returns:
        float: The calculated entropy in bits
    """
    if not password:
        return 0.0
    
    # Calculate character pool size
    has_lowercase = bool(re.search(r'[a-z]', password))
    has_uppercase = bool(re.search(r'[A-Z]', password))
    has_digits = bool(re.search(r'[0-9]', password))
    has_symbols = bool(re.search(r'[^a-zA-Z0-9]', password))
    
    pool_size = 0
    if has_lowercase:
        pool_size += 26
    if has_uppercase:
        pool_size += 26
    if has_digits:
        pool_size += 10
    if has_symbols:
        pool_size += 33  # Approximation for common symbols
    
    # Calculate entropy
    entropy = len(password) * math.log2(max(pool_size, 1))
    return entropy

def rate_password_strength(password: str) -> Dict[str, Any]:
    """
    Rate the strength of a password based on various factors.
    
    Args:
        password: The password to analyze
        
    Returns:
        Dict: A dictionary containing strength metrics and rating
    """
    entropy = calculate_entropy(password)
    patterns = detect_patterns(password)
    
    # Define strength categories
    if entropy < 28:
        strength = "Very Weak"
        score = 1
    elif entropy < 36:
        strength = "Weak"
        score = 2
    elif entropy < 60:
        strength = "Moderate"
        score = 3
    elif entropy < 80:
        strength = "Strong"
        score = 4
    else:
        strength = "Very Strong"
        score = 5
    
    # Adjust score based on patterns
    if patterns:
        score = max(1, score - len(patterns))
        
    return {
        "password": password,
        "entropy": entropy,
        "strength": strength,
        "score": score,
        "patterns": patterns,
        "length": len(password)
    }

# -----------------------------------------------------------------------------
# Pattern Analysis
# -----------------------------------------------------------------------------

def analyze_patterns(passwords: List[str]) -> Dict[str, Any]:
    """
    Analyze patterns across a list of passwords.
    
    Args:
        passwords: List of passwords to analyze
        
    Returns:
        Dict: Analysis results including pattern frequency and statistics
    """
    if not passwords:
        return {}
    
    results = {
        "total_passwords": len(passwords),
        "length_stats": {},
        "character_stats": {},
        "pattern_stats": {},
        "strength_distribution": {
            "Very Weak": 0,
            "Weak": 0,
            "Moderate": 0,
            "Strong": 0,
            "Very Strong": 0
        },
        "pattern_frequency": {},
        "common_patterns": {}
    }
    
    # Analyze lengths
    lengths = [len(pwd) for pwd in passwords]
    results["length_stats"] = {
        "min": min(lengths),
        "max": max(lengths),
        "avg": sum(lengths) / len(lengths),
        "distribution": dict(Counter(lengths))
    }
    
    # Analyze character composition
    has_lowercase = sum(1 for pwd in passwords if re.search(r'[a-z]', pwd))
    has_uppercase = sum(1 for pwd in passwords if re.search(r'[A-Z]', pwd))
    has_digits = sum(1 for pwd in passwords if re.search(r'[0-9]', pwd))
    has_symbols = sum(1 for pwd in passwords if re.search(r'[^a-zA-Z0-9]', pwd))
    
    results["character_stats"] = {
        "lowercase_percent": (has_lowercase / len(passwords)) * 100,
        "uppercase_percent": (has_uppercase / len(passwords)) * 100,
        "digits_percent": (has_digits / len(passwords)) * 100,
        "symbols_percent": (has_symbols / len(passwords)) * 100
    }
    
    # Analyze patterns
    pattern_counts = Counter()
    for password in passwords:
        patterns = detect_patterns(password)
        for pattern_type, matches in patterns.items():
            pattern_counts[pattern_type] += 1
    
    results["pattern_frequency"] = dict(pattern_counts)
    
    # Find most common patterns
    common_patterns = {}
    for pattern_type in PATTERNS.keys():
        matches = []
        for password in passwords:
            patterns = detect_patterns(password)
            if pattern_type in patterns:
                matches.extend(patterns[pattern_type])
        if matches:
            common_patterns[pattern_type] = dict(Counter(matches))
    
    results["common_patterns"] = common_patterns
    
    # Analyze strength distribution
    strength_scores = [rate_password_strength(pwd) for pwd in passwords]
    for score in strength_scores:
        results["strength_distribution"][score["strength"]] += 1
    
    # Convert to percentages
    for key, value in results["strength_distribution"].items():
        results["strength_distribution"][key] = (value / len(passwords)) * 100
    
    return results

# -----------------------------------------------------------------------------
# Visualization Functions
# -----------------------------------------------------------------------------

def generate_visualizations(analysis_results: Dict[str, Any], output_dir: str) -> None:
    """
    Generate visualizations from password analysis results.
    
    Args:
        analysis_results: Results from analyze_patterns function
        output_dir: Directory to save visualizations
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Set style for better visibility
    plt.style.use('seaborn')
    
    # Length distribution visualization
    plt.figure(figsize=(10, 6))
    lengths = analysis_results["length_stats"]["distribution"]
    plt.bar(lengths.keys(), lengths.values())
    plt.title("Password Length Distribution")
    plt.xlabel("Password Length")
    plt.ylabel("Frequency")
    plt.grid(True, alpha=0.3)
    plt.savefig(output_path / "length_distribution.png")
    plt.close()
    
    # Character composition visualization
    plt.figure(figsize=(10, 6))
    char_stats = analysis_results["character_stats"]
    plt.bar(char_stats.keys(), char_stats.values())
    plt.title("Character Type Distribution")
    plt.xlabel("Character Type")
    plt.ylabel("Percentage (%)")
    plt.ylim(0, 100)
    plt.grid(True, alpha=0.3)
    plt.savefig(output_path / "character_distribution.png")
    plt.close()
    
    # Strength distribution visualization
    plt.figure(figsize=(10, 6))
    strength_dist = analysis_results["strength_distribution"]
    plt.pie(
        strength_dist.values(),
        labels=strength_dist.keys(),
        autopct='%1.1f%%',
        startangle=90
    )
    plt.title("Password Strength Distribution")
    plt.savefig(output_path / "strength_distribution.png")
    plt.close()
    
    # Pattern frequency visualization
    plt.figure(figsize=(12, 6))
    pattern_freq = analysis_results["pattern_frequency"]
    if pattern_freq:
        plt.bar(pattern_freq.keys(), pattern_freq.values())
        plt.title("Pattern Type Frequency")
        plt.xlabel("Pattern Type")
        plt.ylabel("Count")
        plt.xticks(rotation=45)
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig(output_path / "pattern_frequency.png")
        plt.close()

# -----------------------------------------------------------------------------
# Report Generation
# -----------------------------------------------------------------------------

def generate_report(analysis_results: Dict[str, Any], output_file: str) -> None:
    """
    Generate a JSON report from the analysis results.
    
    Args:
        analysis_results: Results from analyze_patterns function
        output_file: Path to save the JSON report
    """
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(analysis_results, f, indent=2)

# -----------------------------------------------------------------------------
# CLI Interface
# -----------------------------------------------------------------------------

@click.group()
def cli():
    """DarkForge Password Analyzer"""
    pass

@cli.command()
@click.option(
    "--password-file",
    required=True,
    help="File containing passwords to analyze (one per line)"
)
@click.option(
    "--output-dir",
    default="./analysis_results",
    help="Directory to save analysis results"
)
@click.option(
    "--no-visuals",
    is_flag=True,
    help="Disable visualization generation"
)
@click.option(
    "--pattern-only",
    is_flag=True,
    help="Only analyze patterns without strength assessment"
)
def analyze(password_file, output_dir, no_visuals, pattern_only):
    """Analyze passwords and generate reports."""
    try:
        click.echo("Reading passwords from file...")
        with open(password_file, 'r', encoding='utf-8') as f:
            passwords = [line.strip() for line in f if line.strip()]
        
        click.echo(f"Analyzing {len(passwords)} passwords...")
        analysis_results = analyze_patterns(passwords)
        
        # Generate timestamp for unique filenames
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Save report
        report_file = output_path / f"password_analysis_report_{timestamp}.json"
        generate_report(analysis_results, report_file)
        
        # Generate visualizations if requested
        if not no_visuals:
            visualization_dir = output_path / "visualizations"
            click.echo("Generating visualizations...")
            generate_visualizations(analysis_results, visualization_dir)
        
        # Display summary
        click.echo("\nAnalysis Summary:")
        click.echo(f"Total passwords analyzed: {analysis_results['total_passwords']}")
        click.echo(f"Average password length: {analysis_results['length_stats']['avg']:.2f}")
        click.echo(f"Report saved to: {report_file}")
        
        if not no_visuals:
            click.echo(f"Visualizations saved to: {output_path}/visualizations/")
        
        # Display pattern statistics if any
        if analysis_results.get("pattern_frequency"):
            click.echo("\nPattern Statistics:")
            for pattern_type, count in analysis_results["pattern_frequency"].items():
                click.echo(f"{pattern_type}: {count} occurrences")
        
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        raise

@cli.command()
@click.option(
    "--password",
    required=True,
    help="Password to analyze"
)
def check(password):
    """Analyze a single password."""
    try:
        results = rate_password_strength(password)
        patterns = detect_patterns(password)
        
        click.echo("\nPassword Analysis Results:")
        click.echo(f"Password: {results['password']}")
        click.echo(f"Length: {results['length']}")
        click.echo(f"Entropy: {results['entropy']:.2f} bits")
        click.echo(f"Strength: {results['strength']} (Score: {results['score']}/5)")
        
        if patterns:
            click.echo("\nDetected Patterns:")
            for pattern_type, matches in patterns.items():
                click.echo(f"{pattern_type}: {', '.join(matches)}")
        else:
            click.echo("\nNo common patterns detected.")
            
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        raise

@cli.command()
@click.option(
    "--password-file",
    required=True,
    help="File containing passwords to export"
)
@click.option(
    "--format",
    required=True,
    help="Export format (hashcat, john, plain)"
)
@click.option(
    "--hash-type",
    help="Hash type for hashcat format (sha256, sha512, etc.)"
)
def attack_export(password_file, format, hash_type):
    """Export passwords to a specified format."""
    try:
        click.echo("Reading passwords from file...")
        with open(password_file, 'r', encoding='utf-8') as f:
            passwords = [line.strip() for line in f if line.strip()]
        
        click.echo(f"Exporting {len(passwords)} passwords to {format} format...")
        
        if format == "hashcat":
            if not hash_type:
                click.echo("Error: Hash type is required for hashcat format", err=True)
                return
            click.echo(f"Exporting to hashcat format with hash type: {hash_type}")
            # Implementation for exporting to hashcat format
        elif format == "john":
            click.echo("Exporting to john format")
            # Implementation for exporting to john format
        elif format == "plain":
            click.echo("Exporting to plain format")
            # Implementation for exporting to plain format
        else:
            click.echo(f"Error: Unsupported export format: {format}", err=True)
            return
        
        # Implementation for exporting passwords
        
        click.echo("Export completed successfully.")
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        raise

if __name__ == "__main__":
    cli() 